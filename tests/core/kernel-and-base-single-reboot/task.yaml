summary: Exercises a simultaneous kernel and base refresh with a single reboot

# TODO make the test work with ubuntu-core-20
systems: [ubuntu-core-18-*, ubuntu-core-20-*]

environment:
    BLOB_DIR: $(pwd)/fake-store-blobdir
    PC_KERNEL_SNAP_ID: pYVQrBcKmBa0mZ4CCN7ExT6jH8rY1hza

prepare: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi
    snap ack "$TESTSLIB/assertions/testrootorg-store.account-key"
    #shellcheck source=tests/lib/store.sh
    . "$TESTSLIB"/store.sh

    # install required snaps
    snap install remarshal jq

    setup_fake_store "$BLOB_DIR"

    core_snap=core20
    if os.query is-core18; then
        core_snap=core18
    fi

    if os.query is-core20 ; then
        # we need to convince snapd that pc-kernel which was repacked during
        # prepare is a valid asserted snap
        snap ack "$TESTSLIB/assertions/developer1.account"
        snap ack "$TESTSLIB/assertions/developer1.account-key"
        # at revision 1
        echo '{"revision": "1"}' > extra-decl-pc-kernel.json
        make_snap_installable_with_id --extra-decl-json extra-decl-pc-kernel.json \
            "$BLOB_DIR" \
            /var/lib/snapd/snaps/pc-kernel_x1.snap \
            "$PC_KERNEL_SNAP_ID"
        # stop snapd
        systemctl stop snapd.service snapd.socket
        cp /var/lib/snapd/state.json state.json
        # fake revision 1 in state
        jq '.data.snaps["pc-kernel"].current = "1"' < state.json > state.tmp.1
        # fake sequence
        jq '.data.snaps["pc-kernel"].sequence[0].revision = "1"' < state.tmp.1 > state.tmp.2
        # snap-id
        jq ".data.snaps[\"pc-kernel\"].sequence[0][\"snap-id\"] = \"$PC_KERNEL_SNAP_ID\"" < state.tmp.2 > state.tmp.3
        # and tracking channel
        jq '.data.snaps["pc-kernel"].channel = "latest/edge"' < state.tmp.3 > state.tmp.4
        cp -v state.tmp.4 /var/lib/snapd/state.json
        # mount point
        mkdir /snap/pc-kernel/1
        rm /snap/pc-kernel/current
        ln -s 1 /snap/pc-kernel/current
        # move the snap file
        mv /var/lib/snapd/snaps/pc-kernel_x1.snap /var/lib/snapd/snaps/pc-kernel_1.snap
        # update mounts and mount units
        systemctl disable --now snap-pc\\x2dkernel-x1.mount
        rmdir /snap/pc-kernel/x1
        # keep a backup copy of the unit
        cp /etc/systemd/system/snap-pc\\x2dkernel-x1.mount snap-pc\\x2dkernel-x1.mount
        mv /etc/systemd/system/snap-pc\\x2dkernel-x1.mount /etc/systemd/system/snap-pc\\x2dkernel-1.mount
        sed -i -e 's#pc-kernel/x1#pc-kernel/1#' \
               -e 's/revision x1/revision 1/' \
               -e 's#snaps/pc-kernel_x1.snap#snaps/pc-kernel_1.snap#' \
               /etc/systemd/system/snap-pc\\x2dkernel-1.mount
        systemctl daemon-reload
        systemctl enable --now snap-pc\\x2dkernel-1.mount
        # make sure the mount is up
        stat /snap/pc-kernel/1/meta/snap.yaml
        systemctl start snapd.service
        # and the revision is 1
        snap list pc-kernel | awk '/pc-kernel/ { print $3 }' | MATCH '^1$'
        snap list pc-kernel | NOMATCH broken
    fi

    readlink /snap/pc-kernel/current > pc-kernel.rev
    readlink "/snap/$core_snap/current" > core.rev

restore: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi
    #shellcheck source=tests/lib/store.sh
    . "$TESTSLIB"/store.sh
    teardown_fake_store "$BLOB_DIR"

    if os.query is-core20 ; then
        systemctl stop snapd.service snapd.socket

        # revert the hacks making pc-kernel look like a legit signed snap
        systemctl disable --now snap-pc\\x2dkernel-1.mount
        # remove the unit file
        rm -f /etc/systemd/system/snap-pc\\x2dkernel-1.mount
        # restore the old one
        cp snap-pc\\x2dkernel-x1.mount /etc/systemd/system/snap-pc\\x2dkernel-x1.mount
        # restore mount directories and the current symlink
        rmdir /snap/pc-kernel/1
        mkdir -p /snap/pc-kernel/x1
        rm /snap/pc-kernel/current
        ln -s x1 /snap/pc-kernel/current
        # and the snap file
        mv /var/lib/snapd/snaps/pc-kernel_1.snap /var/lib/snapd/snaps/pc-kernel_x1.snap
        systemctl daemon-reload
        systemctl enable --now snap-pc\\x2dkernel-x1.mount
        # restore the state
        mv state.json /var/lib/snapd/state.json
        # verify that we're good
        systemctl start snapd.service
        # and the revision is back to x1
        snap list pc-kernel | awk '/pc-kernel/ { print $3 }' | MATCH '^x1$'
        snap list pc-kernel | NOMATCH broken
    fi

debug: |
    journalctl --no-pager --no-hostname -u fakestore || true

execute: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi

    #shellcheck source=tests/lib/store.sh
    . "$TESTSLIB"/store.sh

    core_snap=core20
    if os.query is-core18; then
        core_snap=core18
    fi

    if [ "$SPREAD_REBOOT" = 0 ]; then
        # pc-kernel may a fake snap declaration signed with test keys, so use
        # the correct fakestore binary to generate a new revision
        FAKESTORE=fakestore-testkeys init_fake_refreshes "$BLOB_DIR" pc-kernel
        init_fake_refreshes "$BLOB_DIR" "$core_snap"

        # taken from transition_to_recover_mode()
        cp /bin/systemctl /tmp/orig-systemctl
        mount -o bind "$TESTSLIB/mock-shutdown" /bin/systemctl
        tests.cleanup defer umount /bin/systemctl

        snap refresh --no-wait "$core_snap" pc-kernel > refresh-change-id
        test -n "$(cat refresh-change-id)"
        change_id="$(cat refresh-change-id)"
        # wait until we observe reboots
        # shellcheck disable=SC2016
        retry -n 100 --wait 5 sh -c 'test "$(wc -l < /tmp/mock-shutdown.calls)" -gt "1"'
        # stop snapd now to avoid snapd waiting for too long and deciding to
        # error out assuming a rollback across reboot
        systemctl stop snapd.service snapd.socket

        # both link snaps should be done now, snapd was stopped, so we cannot
        # use 'snap change' and we need to inspect the state directly (even if
        # snapd was up, it would not respond to API requests as it would be busy
        # retrying auto-connect)
        snap debug state --change "$change_id" /var/lib/snapd/state.json > tasks.state
        # both link snaps are done
        MATCH ' Done\s+.*Make snap "pc-kernel" .* available' < tasks.state
        MATCH " Done\s+.*Make snap \"$core_snap\" .* available" < tasks.state
        # auto-connect of the base is in doing and waiting for reboot
        MATCH " Doing\s+.*Automatically connect eligible plugs and slots of snap \"$core_snap\"" < tasks.state
        # auto-connect of the kernel is still queued
        MATCH ' Do\s+.*Automatically connect eligible plugs and slots of snap "pc-kernel"' < tasks.state

        if os.query is-core18; then
            snap debug boot-vars > boot-vars.dump
            MATCH 'snap_mode=try' < boot-vars.dump
            MATCH 'snap_try_core=core18_.*.snap' < boot-vars.dump
            MATCH 'snap_try_kernel=pc-kernel_.*.snap' < boot-vars.dump
        elif os.query is-core20; then
            stat /boot/grub/kernel.efi | MATCH 'pc_kernel.*.snap/kernel.efi'
            stat -L /boot/grub/kernel.efi
            stat /boot/grub/try-kernel.efi | MATCH 'pc_kernel.*.snap/kernel.efi'
            stat -L /boot/grub/try-kernel.efi
        else
            echo "unsupported Ubuntu Core system"
            exit 1
        fi

        # restore shutdown so that spread can reboot the host
        tests.cleanup pop

        REBOOT
    elif [ "$SPREAD_REBOOT" = 1 ]; then
        change_id="$(cat refresh-change-id)"
        # XXX: is this sufficiently robust?
        snap watch "$change_id" || true
        snap changes | MATCH "$change_id\s+(Done|Error)"
        # we expect re-refresh to fail since the tests uses a fake store
        snap change "$change_id" > tasks.done
        MATCH '^Error .* Handling re-refresh' < tasks.done
        # no other errors
        grep -v 'Handling re-refresh' < tasks.done | NOMATCH '^Error'
        # nothing was undone
        grep -v 'Handling re-refresh' < tasks.done | NOMATCH '^Undone'
        # we did not even try to hijack shutdown (/bin/systemctl) because that
        # could race with snapd (if that wanted to call it), so just check that
        # the system is in a stable state once we have already determined that
        # the change is complete
        # XXX systemctl exits with non-0 when in degraded state
        (systemctl is-system-running || true) | MATCH '(running|degraded)'

        # fake refreshes generate revision numbers that are n+1
        expecting_kernel="$(($(cat pc-kernel.rev) + 1))"
        expecting_core="$(($(cat core.rev) + 1))"

        # verify that current points to new revisions
        test "$(readlink /snap/pc-kernel/current)" = "$expecting_kernel"
        test "$(readlink /snap/$core_snap/current)" = "$expecting_core"

        # now we need to revert both snaps for restore to behave properly, start
        # with the kernel
        snap revert pc-kernel --revision "$(cat pc-kernel.rev)"
        REBOOT
    elif [ "$SPREAD_REBOOT" = 2 ]; then
        snap watch --last=revert\?
        # now the base
        snap revert "$core_snap" --revision "$(cat core.rev)"
        REBOOT
    elif [ "$SPREAD_REBOOT" = 3 ]; then
        snap watch --last=revert\?
        # we're done, verify current symlinks to the right revisions
        test "$(readlink /snap/pc-kernel/current)" = "$(cat pc-kernel.rev)"
        test "$(readlink /snap/$core_snap/current)" = "$(cat core.rev)"
    else
        echo "unexpected reboot"
        exit 1
    fi
